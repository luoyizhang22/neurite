import React, { useState, useRef, useCallback, useEffect } from 'react';import ReactFlow, {  MiniMap,  Controls,  Background,  useNodesState,  useEdgesState,  addEdge,  Connection,  Edge,  Node,  NodeChange,  EdgeChange,  NodeTypes,  EdgeTypes,  useReactFlow,  ReactFlowProvider,  Panel} from 'reactflow';import 'reactflow/dist/style.css';import {  Box,  Button,  IconButton,  Menu,  MenuButton,  MenuItem,  MenuList,  Flex,  Heading,  Text,  useDisclosure,  Drawer,  DrawerBody,  DrawerHeader,  DrawerOverlay,  DrawerContent,  DrawerCloseButton,  Tabs,  TabList,  Tab,  TabPanels,  TabPanel,  Tooltip,  useToast,  Badge,  VStack,  HStack,  Divider,  Image,  Link,  Modal,  ModalOverlay,  ModalContent,  ModalCloseButton,  useColorModeValue} from '@chakra-ui/react';import { FiPlus, FiSave, FiTrash2, FiZoomIn, FiZoomOut, FiCpu, FiImage, FiLink, FiZap,   FiRotateCcw, FiRotateCw, FiSettings, FiFileText, FiHelpCircle, FiMessageCircle,   FiUsers, FiArrowRightCircle, FiMaximize, FiBookOpen, FiMessageSquare, FiMoreVertical,  FiList, FiShare2, FiGitBranch, FiActivity, FiEye, FiLayers, FiEdit2, FiTrash, FiExternalLink } from 'react-icons/fi';import nodeTypes from '@components/nodes';import edgeTypes from '@components/edges';import { INode } from '@types/graph';import { useDispatch, useSelector } from 'react-redux';import { addNode } from '@store/slices/nodesSlice';import { RootState } from '@store/index';import { v4 as uuidv4 } from 'uuid';// 模拟数据 - 在真实应用中会从Redux获取import { useParams, useNavigate } from 'react-router-dom';import DebateAssistant from '@components/ai/DebateAssistant';import KnowledgeTree from '../components/knowledge/KnowledgeTree';import AIModelSettings from '@components/settings/AIModelSettings';import MultiNodeQuery from '@components/ai/MultiNodeQuery';const mockNodes = [  {     id: 'node1',     type: 'text',     position: { x: 100, y: 100 },     content: '核心思考点：人类学习的非线性特性',     isSelected: false   },  {     id: 'node2',     type: 'text',     position: { x: 300, y: 50 },     content: '传统笔记的局限性：线性记录难以表达复杂关系',     isSelected: false   },  {     id: 'node3',     type: 'text',     position: { x: 300, y: 150 },     content: '提出解决方案：结构化的知识节点与动态连接',     isSelected: false   },];const mockConnections = [  { id: 'conn1', source: 'node1', target: 'node2' },  { id: 'conn2', source: 'node1', target: 'node3' },];const GraphPage = () => {  const { graphId } = useParams<{ graphId: string }>();  const navigate = useNavigate();  const toast = useToast();  const canvasRef = useRef<HTMLDivElement>(null);  const { isOpen, onOpen, onClose } = useDisclosure();  const {     isOpen: isDebateOpen,     onOpen: onOpenDebate,     onClose: onCloseDebate   } = useDisclosure();    const [isMultiNodeQueryOpen, setIsMultiNodeQueryOpen] = useState(false);  const [isAISettingsOpen, setIsAISettingsOpen] = useState(false);    // 状态  const [nodes, setNodes] = useState(mockNodes);  const [connections, setConnections] = useState(mockConnections);  const [zoom, setZoom] = useState(1);  const [position, setPosition] = useState({ x: 0, y: 0 });  const [isDragging, setIsDragging] = useState(false);  const [dragStart, setDragStart] = useState({ x: 0, y: 0 });  const [nodeDragging, setNodeDragging] = useState<string | null>(null);  const [showMiniMap, setShowMiniMap] = useState(true);  const [graphTitle, setGraphTitle] = useState(`思维导图 ${graphId}`);  const [isKnowledgeTreeOpen, setIsKnowledgeTreeOpen] = useState(false);  const [bgColor, setBgColor] = useState('');    // 颜色模式相关值  const defaultBgColor = useColorModeValue('gray.50', 'gray.800');  const connectionColor = useColorModeValue('gray.500', 'gray.400');  const nodeColor = useColorModeValue('white', 'gray.800');  const nodeBorderColor = useColorModeValue('gray.200', 'gray.600');  const headerBgColor = useColorModeValue('white', 'gray.800');  const headerBorderColor = useColorModeValue('gray.200', 'gray.700');  const modalBgColor = useColorModeValue('white', 'gray.700');  const drawerBgColor = useColorModeValue('white', 'gray.800');  const drawerBorderColor = useColorModeValue('gray.200', 'gray.600');  const selectedBorderColor = 'purple.400';    // 使用 useEffect 来设置背景色  useEffect(() => {    setBgColor(defaultBgColor);  }, [defaultBgColor]);    // 添加框选状态变量  const [selectionBox, setSelectionBox] = useState({     isActive: false,     start: { x: 0, y: 0 },     end: { x: 0, y: 0 }   });    // 在组件顶部添加历史记录状态  const [history, setHistory] = useState<{nodes: any[], connections: any[]}[]>([]);  const [historyIndex, setHistoryIndex] = useState(-1);    const dispatch = useDispatch();    // 保存当前状态到历史记录  const saveToHistory = () => {    // 如果当前不是历史的最后一步，则截断历史    const newHistory = historyIndex < history.length - 1      ? history.slice(0, historyIndex + 1)      : [...history];          // 添加当前状态到历史    newHistory.push({      nodes: [...nodes],      connections: [...connections]    });        // 限制历史记录长度为50步    if (newHistory.length > 50) {      newHistory.shift();    }        setHistory(newHistory);    setHistoryIndex(newHistory.length - 1);  };    // 撤销操作  const undo = () => {    if (historyIndex > 0) {      const newIndex = historyIndex - 1;      const previousState = history[newIndex];            setNodes(previousState.nodes);      setConnections(previousState.connections);      setHistoryIndex(newIndex);            toast({        title: "已撤销",        status: "info",        duration: 1000,        isClosable: true,      });    } else {      toast({        title: "无法撤销",        description: "已经是最早的操作记录",        status: "warning",        duration: 1500,        isClosable: true,      });    }  };    // 重做操作  const redo = () => {    if (historyIndex < history.length - 1) {      const newIndex = historyIndex + 1;      const nextState = history[newIndex];            setNodes(nextState.nodes);      setConnections(nextState.connections);      setHistoryIndex(newIndex);            toast({        title: "已重做",        status: "info",        duration: 1000,        isClosable: true,      });    } else {      toast({        title: "无法重做",        description: "已经是最新的操作记录",        status: "warning",        duration: 1500,        isClosable: true,      });    }  };    // 加载数据 (模拟)  useEffect(() => {    if (graphId === 'new') {      setGraphTitle('新建思维导图');      setNodes([]);      setConnections([]);    } else {      // 实际应用中从Redux加载数据      console.log(`加载图谱ID: ${graphId}`);    }  }, [graphId]);    // 添加键盘事件处理  useEffect(() => {    const handleKeyDown = (e: KeyboardEvent) => {      // 删除选中节点 (Delete键或Backspace键)      if ((e.key === 'Delete' || e.key === 'Backspace') && document.activeElement === document.body) {        const selectedIds = nodes.filter(node => node.isSelected).map(node => node.id);        if (selectedIds.length > 0) {          // 删除节点          setNodes(nodes.filter(node => !node.isSelected));                    // 删除相关连接          setConnections(connections.filter(            conn => !selectedIds.includes(conn.source) && !selectedIds.includes(conn.target)          ));                    toast({            title: `已删除 ${selectedIds.length} 个节点`,            status: "success",            duration: 1500,            isClosable: true,          });        }      }            // 全选 (Ctrl+A)      if (e.key === 'a' && (e.ctrlKey || e.metaKey) && document.activeElement === document.body) {        e.preventDefault();        setNodes(nodes.map(node => ({          ...node,          isSelected: true        })));      }            // 取消选择 (Escape键)      if (e.key === 'Escape') {        setNodes(nodes.map(node => ({          ...node,          isSelected: false        })));      }            // 复制选中节点 (Ctrl+C)      if (e.key === 'c' && (e.ctrlKey || e.metaKey) && document.activeElement === document.body) {        const selectedNodes = nodes.filter(node => node.isSelected);        if (selectedNodes.length > 0) {          // 将选中节点存储在sessionStorage中          sessionStorage.setItem('copiedNodes', JSON.stringify(selectedNodes));                    toast({            title: `已复制 ${selectedNodes.length} 个节点`,            status: "info",            duration: 1500,            isClosable: true,          });        }      }            // 粘贴节点 (Ctrl+V)      if (e.key === 'v' && (e.ctrlKey || e.metaKey) && document.activeElement === document.body) {        const copiedNodesString = sessionStorage.getItem('copiedNodes');        if (copiedNodesString) {          try {            const copiedNodes = JSON.parse(copiedNodesString);                        // 为复制的节点创建新的ID并调整位置            const newNodes = copiedNodes.map((node: any, index: number) => {              const newId = `node${nodes.length + index + 1}`;              return {                ...node,                id: newId,                position: {                  x: node.position.x + 50,                  y: node.position.y + 50                },                isSelected: true              };            });                        // 更新节点状态，先取消现有选择            setNodes([              ...nodes.map(node => ({ ...node, isSelected: false })),              ...newNodes            ]);                        toast({              title: `已粘贴 ${newNodes.length} 个节点`,              status: "success",              duration: 1500,              isClosable: true,            });          } catch (error) {            console.error('粘贴节点时出错:', error);            toast({              title: "粘贴失败",              description: "无法解析复制的节点数据",              status: "error",              duration: 2000,              isClosable: true,            });          }        }      }            // 撤销操作 (Ctrl+Z)      if (e.key === 'z' && (e.ctrlKey || e.metaKey) && document.activeElement === document.body) {        e.preventDefault();        undo();      }            // 重做操作 (Ctrl+Y 或 Ctrl+Shift+Z)      if ((e.key === 'y' && (e.ctrlKey || e.metaKey)) ||           (e.key === 'z' && (e.ctrlKey || e.metaKey) && e.shiftKey) &&           document.activeElement === document.body) {        e.preventDefault();        redo();      }    };        // 添加键盘事件监听器    window.addEventListener('keydown', handleKeyDown);        // 清理函数    return () => {      window.removeEventListener('keydown', handleKeyDown);    };  }, [nodes, connections, setNodes, setConnections, toast, history, historyIndex]);    // 修改canvas鼠标按下事件处理函数  const handleCanvasMouseDown = (e: React.MouseEvent) => {    if (e.target === canvasRef.current) {      if (e.shiftKey) {        // 启动框选模式        const rect = canvasRef.current?.getBoundingClientRect();        if (rect) {          const startX = (e.clientX - rect.left) / zoom - position.x / zoom;          const startY = (e.clientY - rect.top) / zoom - position.y / zoom;          setSelectionBox({            isActive: true,            start: { x: startX, y: startY },            end: { x: startX, y: startY }          });        }      } else {        // 普通画布拖动        setIsDragging(true);        setDragStart({ x: e.clientX, y: e.clientY });                // 如果没有按住Shift，则清除所有节点选择        setNodes(nodes.map(node => ({          ...node,          isSelected: false        })));      }    }  };    // 修改鼠标移动函数处理框选  const handleCanvasMouseMove = (e: React.MouseEvent) => {    if (isDragging) {      // 画布拖动逻辑      const dx = e.clientX - dragStart.x;      const dy = e.clientY - dragStart.y;      setPosition({        x: position.x + dx,        y: position.y + dy      });      setDragStart({ x: e.clientX, y: e.clientY });    } else if (nodeDragging) {      // 节点拖动逻辑      const dx = e.clientX - dragStart.x;      const dy = e.clientY - dragStart.y;            setNodes(nodes.map(node => {        // 如果是被拖动的节点或其他被选中的节点，则移动它们        if (node.id === nodeDragging || (node.isSelected && nodeDragging)) {          return {            ...node,            position: {              x: node.position.x + dx,              y: node.position.y + dy            }          };        }        return node;      }));            setDragStart({ x: e.clientX, y: e.clientY });    } else if (selectionBox.isActive) {      // 更新框选区域      const rect = canvasRef.current?.getBoundingClientRect();      if (rect) {        const currentX = (e.clientX - rect.left) / zoom - position.x / zoom;        const currentY = (e.clientY - rect.top) / zoom - position.y / zoom;                setSelectionBox({          ...selectionBox,          end: { x: currentX, y: currentY }        });                // 计算选择框的坐标范围        const x1 = Math.min(selectionBox.start.x, currentX);        const y1 = Math.min(selectionBox.start.y, currentY);        const x2 = Math.max(selectionBox.start.x, currentX);        const y2 = Math.max(selectionBox.start.y, currentY);                // 根据节点是否在选择框内更新节点的选择状态        setNodes(nodes.map(node => {          const nodeInBox =             node.position.x >= x1 &&             node.position.x <= x2 &&             node.position.y >= y1 &&             node.position.y <= y2;                    return {            ...node,            isSelected: nodeInBox || node.isSelected          };        }));      }    }  };    // 修改鼠标释放函数，处理框选结束  const handleCanvasMouseUp = () => {    // 如果有节点被拖动，保存历史    if (nodeDragging) {      saveToHistory();    }        setIsDragging(false);    setNodeDragging(null);        // 重置选择框    if (selectionBox.isActive) {      // 如果有使用选择框选择节点，保存历史      const anyNodeSelected = nodes.some(node => node.isSelected);      if (anyNodeSelected) {        saveToHistory();      }            setSelectionBox({         isActive: false,         start: { x: 0, y: 0 },         end: { x: 0, y: 0 }       });    }  };    // 节点事件处理  const handleNodeSelect = (id: string, event: React.MouseEvent) => {    event.stopPropagation();        saveToHistory();        if (event.shiftKey) {      setNodes(nodes.map(node => ({        ...node,        isSelected: node.id === id ? !node.isSelected : node.isSelected      })));    } else {      setNodes(nodes.map(node => ({        ...node,        isSelected: node.id === id      })));    }  };    const handleNodeDragStart = (id: string, event: React.MouseEvent) => {    event.stopPropagation();    setNodeDragging(id);    setDragStart({ x: event.clientX, y: event.clientY });        if (!nodes.find(node => node.id === id)?.isSelected && !event.shiftKey) {      setNodes(nodes.map(node => ({        ...node,        isSelected: node.id === id      })));    }  };    const handleNodeDragMove = (event: React.MouseEvent) => {    if (nodeDragging) {      const dx = event.clientX - dragStart.x;      const dy = event.clientY - dragStart.y;            setNodes(nodes.map(node => {        if (node.id === nodeDragging) {          return {            ...node,            position: {              x: node.position.x + dx,              y: node.position.y + dy            }          };        }        return node;      }));            setDragStart({ x: event.clientX, y: event.clientY });    }  };    // 缩放控制  const handleZoomIn = () => {    setZoom(Math.min(zoom + 0.1, 2));  };    const handleZoomOut = () => {    setZoom(Math.max(zoom - 0.1, 0.5));  };    const handleResetZoom = () => {    setZoom(1);    setPosition({ x: 0, y: 0 });  };    // 添加不同类型的节点  const addTextNode = () => {    saveToHistory();    const newNode = createTextNode('新文本节点');        setNodes([      ...nodes.map(node => ({ ...node, isSelected: false })),      newNode    ]);        toast({      title: "已添加文本节点",      status: "success",      duration: 1500,      isClosable: true,    });  };    const addImageNode = () => {    saveToHistory();    const newNode = createImageNode('https://via.placeholder.com/150');        setNodes([      ...nodes.map(node => ({ ...node, isSelected: false })),      newNode    ]);        toast({      title: "已添加图片节点",      status: "success",      duration: 1500,      isClosable: true,    });  };    const addLinkNode = () => {    saveToHistory();    const newNode = createLinkNode('https://example.com');        setNodes([      ...nodes.map(node => ({ ...node, isSelected: false })),      newNode    ]);        toast({      title: "已添加链接节点",      status: "success",      duration: 1500,      isClosable: true,    });  };    const addAINode = () => {    saveToHistory();    const newNode = createChatNode('请输入您的问题...');        setNodes([      ...nodes.map(node => ({ ...node, isSelected: false })),      newNode    ]);        toast({      title: "已添加AI节点",      status: "success",      duration: 1500,      isClosable: true,    });  };    // 添加辩论节点  const addDebateNode = () => {    saveToHistory();    const newNode = createDebateNode('添加辩论话题');        setNodes([      ...nodes.map(node => ({ ...node, isSelected: false })),      newNode    ]);        toast({      title: "已添加辩论节点",      status: "success",      duration: 1500,      isClosable: true,    });  };    // 添加端口节点  const addPortNode = () => {    saveToHistory();    const newNode = createPortNode('处理模块');        setNodes([      ...nodes.map(node => ({ ...node, isSelected: false })),      newNode    ]);        toast({      title: "已添加处理模块节点",      status: "success",      duration: 1500,      isClosable: true,    });  };    // 添加formatBionicText函数  const formatBionicText = (text: string): string => {    if (!text) return '';        // 按单词分割文本    return text.split(' ').map(word => {      // 对于较短的单词，加粗前半部分      if (word.length <= 3) {        return `<strong>${word}</strong>`;      }            // 对于较长的单词，加粗前60%      const boldLength = Math.ceil(word.length * 0.6);      const boldPart = word.substring(0, boldLength);      const normalPart = word.substring(boldLength);            return `<strong>${boldPart}</strong>${normalPart}`;    }).join(' ');  };    // 添加创建仿生阅读节点的函数  const addBionicTextNode = () => {    saveToHistory();    const newNode = createBionicTextNode();        setNodes([      ...nodes.map(node => ({ ...node, isSelected: false })),      newNode    ]);        toast({      title: "已添加仿生阅读节点",      status: "success",      duration: 1500,      isClosable: true,    });  };    // 处理从辩论助手添加节点  const handleAddDebateNode = (nodeData: any) => {    saveToHistory();        let newNode;    if (nodeData.type === 'debate') {      newNode = createDebateNode(nodeData.content || '辩论话题');      // 如果有额外数据，合并到节点数据中      if (nodeData.data) {        newNode.data = {          ...newNode.data,          ...nodeData.data        };      }    } else {      // 默认创建辩论节点      newNode = createDebateNode(nodeData.content || '辩论话题');    }        setNodes([      ...nodes.map(node => ({ ...node, isSelected: false })),      newNode    ]);        toast({      title: "已添加辩论节点",      status: "success",      duration: 1500,      isClosable: true,    });  };    // 处理节点编辑  const handleNodeEdit = (nodeId: string, newContent: string, additionalData?: any) => {    try {      saveToHistory();      const nodeIndex = nodes.findIndex(node => node.id === nodeId);      if (nodeIndex === -1) {        throw new Error(`节点 ${nodeId} 不存在`);      }            const updatedNodes = [...nodes];      updatedNodes[nodeIndex] = {        ...updatedNodes[nodeIndex],        content: newContent      };            setNodes(updatedNodes);            toast({        title: "节点已更新",        status: "success",        duration: 1500,        isClosable: true,      });    } catch (error) {      console.error("编辑节点时出错:", error);      toast({        title: "编辑节点失败",        description: error instanceof Error ? error.message : "未知错误",        status: "error",        duration: 2000,        isClosable: true,      });    }  };    // 修复连接节点功能  const connectSelectedNodes = () => {    // 获取选中的节点ID    const selectedNodes = nodes.filter(node => node.isSelected);        // 检查是否有两个节点被选中    if (selectedNodes.length !== 2) {      toast({        title: "请选择两个节点进行连接",        status: "warning",        duration: 2000,        isClosable: true,      });      return;    }        const sourceId = selectedNodes[0].id;    const targetId = selectedNodes[1].id;        // 检查是否已存在相同的连接    const connectionExists = connections.some(      conn => (conn.source === sourceId && conn.target === targetId) ||               (conn.source === targetId && conn.target === sourceId)    );        if (connectionExists) {      toast({        title: "连接已存在",        description: "这两个节点已经连接",        status: "info",        duration: 2000,        isClosable: true,      });      return;    }        // 创建新连接前保存历史    saveToHistory();        // 创建新连接    const newConnection = {      id: `conn${connections.length + 1}`,      source: sourceId,      target: targetId    };        setConnections([...connections, newConnection]);        toast({      title: "已创建连接",      status: "success",      duration: 1500,      isClosable: true,    });  };    // 添加删除连接功能  const deleteConnection = (connectionId: string) => {    saveToHistory();    setConnections(connections.filter(conn => conn.id !== connectionId));        toast({      title: "已删除连接",      status: "success",      duration: 1500,      isClosable: true,    });  };    // 添加连接线点击处理  const handleConnectionClick = (connectionId: string) => {    // 使用confirm确认是否删除连接    if (window.confirm("是否要删除此连接？")) {      deleteConnection(connectionId);    }  };    // 添加端口连接逻辑  const connectPorts = (sourceNodeId: string, sourcePortId: string, targetNodeId: string, targetPortId: string) => {    // 检查源节点和目标节点是否存在    const sourceNode = nodes.find(node => node.id === sourceNodeId);    const targetNode = nodes.find(node => node.id === targetNodeId);        if (!sourceNode || !targetNode) {      toast({        title: "无法连接端口",        description: "源节点或目标节点不存在",        status: "error",        duration: 2000,        isClosable: true,      });      return false;    }        // 确保节点是端口类型    if (sourceNode.type !== 'port' || targetNode.type !== 'port') {      toast({        title: "无法连接端口",        description: "只能连接处理模块节点的端口",        status: "warning",        duration: 2000,        isClosable: true,      });      return false;    }        // 检查端口是否已连接    const connectionExists = connections.some(      conn => (conn.source === `${sourceNodeId}:${sourcePortId}` && conn.target === `${targetNodeId}:${targetPortId}`) ||             (conn.source === `${targetNodeId}:${targetPortId}` && conn.target === `${sourceNodeId}:${sourcePortId}`)    );        if (connectionExists) {      toast({        title: "端口已连接",        description: "这两个端口已经存在连接",        status: "info",        duration: 2000,        isClosable: true,      });      return false;    }        // 创建新连接    const newConnection = {      id: `conn${connections.length + 1}`,      source: `${sourceNodeId}:${sourcePortId}`,      target: `${targetNodeId}:${targetPortId}`,      type: 'port-connection'    };        setConnections([...connections, newConnection]);        // 更新节点端口的连接信息    setNodes(nodes.map(node => {      if (node.id === sourceNodeId) {        // 更新源节点的输出端口        const updatedOutputs = node.data.outputs.map((port: any) => {          if (port.id === sourcePortId) {            return {              ...port,              connections: [...(port.connections || []), {                 nodeId: targetNodeId,                 portId: targetPortId               }]            };          }          return port;        });                return {          ...node,          data: {            ...node.data,            outputs: updatedOutputs          }        };      }       else if (node.id === targetNodeId) {        // 更新目标节点的输入端口        const updatedInputs = node.data.inputs.map((port: any) => {          if (port.id === targetPortId) {            return {              ...port,              connections: [...(port.connections || []), {                 nodeId: sourceNodeId,                 portId: sourcePortId               }]            };          }          return port;        });                return {          ...node,          data: {            ...node.data,            inputs: updatedInputs          }        };      }      return node;    }));        toast({      title: "已连接端口",      status: "success",      duration: 1500,      isClosable: true,    });        return true;  };    // 更新端口节点的渲染函数  const renderPortNode = (node: any) => {    return (      <Box>        <Flex justify="space-between" align="center" mb={2}>          <Badge colorScheme="orange">处理模块</Badge>          {node.isSelected && (            <IconButton              aria-label="编辑节点"              icon={<FiEdit2 size="14px" />}              size="xs"              variant="ghost"              onClick={(e) => {                e.stopPropagation();                const newTitle = prompt("编辑模块标题", node.data?.title || "");                if (newTitle !== null) {                  handleNodeEdit(node.id, node.content, { title: newTitle });                }              }}            />          )}        </Flex>        <Text fontWeight="bold">{node.data?.title || "处理模块"}</Text>        <Text fontSize="sm" mb={2}>{node.data?.description || ""}</Text>                {/* 输入端口 */}        <Box mt={3} mb={2}>          <Text fontSize="xs" fontWeight="bold" mb={1}>输入:</Text>          {node.data?.inputs?.map((input: any, index: number) => (            <Flex key={input.id} align="center" mb={1}>              <Box                 w="10px"                 h="10px"                 borderRadius="full"                 bg="blue.400"                 mr={2}                data-port-id={input.id}                data-port-type="input"                data-node-id={node.id}                cursor="pointer"                _hover={{ boxShadow: "0 0 0 2px blue.300" }}                onClick={(e) => {                  e.stopPropagation();                  // 处理端口点击 - 此处可添加连接逻辑                  console.log(`输入端口点击: ${node.id}:${input.id}`);                }}              />              <Text fontSize="xs">{input.name}</Text>            </Flex>          ))}        </Box>                {/* 输出端口 */}        <Box mb={2}>          <Text fontSize="xs" fontWeight="bold" mb={1}>输出:</Text>          {node.data?.outputs?.map((output: any, index: number) => (            <Flex key={output.id} align="center" mb={1} justify="flex-end">              <Text fontSize="xs">{output.name}</Text>              <Box                 w="10px"                 h="10px"                 borderRadius="full"                 bg="green.400"                 ml={2}                data-port-id={output.id}                data-port-type="output"                data-node-id={node.id}                cursor="pointer"                _hover={{ boxShadow: "0 0 0 2px green.300" }}                onClick={(e) => {                  e.stopPropagation();                  // 处理端口点击 - 此处可添加连接逻辑                  console.log(`输出端口点击: ${node.id}:${output.id}`);                }}              />            </Flex>          ))}        </Box>      </Box>    );  };    // 渲染节点内容  const renderNodeContent = (node: any) => {    switch (node.type) {      case 'text':        return (          <Box>            <Flex justify="space-between" align="center" mb={2}>              <Badge colorScheme="blue">文本</Badge>              {node.isSelected && (                <IconButton                  aria-label="编辑节点"                  icon={<FiEdit2 size="14px" />}                  size="xs"                  variant="ghost"                  onClick={(e) => {                    e.stopPropagation();                    const newContent = prompt("编辑节点内容", node.content);                    if (newContent !== null) {                      handleNodeEdit(node.id, newContent);                    }                  }}                />              )}            </Flex>            <Text>{node.content}</Text>          </Box>        );              case 'image':        return (          <Box>            <Flex justify="space-between" align="center" mb={2}>              <Badge colorScheme="green">图片</Badge>              {node.isSelected && (                <IconButton                  aria-label="编辑节点"                  icon={<FiEdit2 size="14px" />}                  size="xs"                  variant="ghost"                  onClick={(e) => {                    e.stopPropagation();                    const newUrl = prompt("编辑图片URL", node.data?.url || "");                    if (newUrl !== null) {                      const updatedNode = {                        ...node,                        data: { ...node.data, url: newUrl }                      };                      const updatedNodes = nodes.map(n =>                         n.id === node.id ? updatedNode : n                      );                      setNodes(updatedNodes);                    }                  }}                />              )}            </Flex>            {node.data?.url ? (              <Image                 src={node.data.url}                 alt={node.content || "图片"}                 maxH="160px"                maxW="280px"                objectFit="contain"                borderRadius="md"              />            ) : (              <Box                 bg="gray.100"                 color="gray.500"                 h="100px"                 display="flex"                 alignItems="center"                 justifyContent="center"                borderRadius="md"              >                <FiImage size="24px" />              </Box>            )}            {node.content && <Text mt={2} fontSize="sm">{node.content}</Text>}          </Box>        );              case 'link':        return (          <Box>            <Flex justify="space-between" align="center" mb={2}>              <Badge colorScheme="purple">链接</Badge>              {node.isSelected && (                <IconButton                  aria-label="编辑节点"                  icon={<FiEdit2 size="14px" />}                  size="xs"                  variant="ghost"                  onClick={(e) => {                    e.stopPropagation();                    const newUrl = prompt("编辑链接URL", node.data?.url || "");                    if (newUrl !== null) {                      const updatedNode = {                        ...node,                        data: { ...node.data, url: newUrl }                      };                      const updatedNodes = nodes.map(n =>                         n.id === node.id ? updatedNode : n                      );                      setNodes(updatedNodes);                    }                  }}                />              )}            </Flex>            <Link href={node.data?.url} isExternal color="blue.500" fontWeight="medium">              {node.content || node.data?.url || "链接"}              <Icon as={FiExternalLink} mx="2px" />            </Link>          </Box>        );              case 'ai':        return (          <Box>            <Flex justify="space-between" align="center" mb={2}>              <Badge colorScheme="teal">AI</Badge>              {node.isSelected && (                <IconButton                  aria-label="编辑节点"                  icon={<FiEdit2 size="14px" />}                  size="xs"                  variant="ghost"                  onClick={(e) => {                    e.stopPropagation();                    const newContent = prompt("编辑AI节点内容", node.content);                    if (newContent !== null) {                      handleNodeEdit(node.id, newContent);                    }                  }}                />              )}            </Flex>            <Text>{node.content}</Text>          </Box>        );              case 'debate':        return (          <Box>            <Flex justify="space-between" align="center" mb={2}>              <Badge colorScheme="red">辩论</Badge>              {node.isSelected && (                <IconButton                  aria-label="编辑节点"                  icon={<FiEdit2 size="14px" />}                  size="xs"                  variant="ghost"                  onClick={(e) => {                    e.stopPropagation();                    const newContent = prompt("编辑辩论节点内容", node.content);                    if (newContent !== null) {                      handleNodeEdit(node.id, newContent);                    }                  }}                />              )}            </Flex>            <Text>{node.content}</Text>          </Box>        );              case 'port':        return renderPortNode(node);              case 'bionicText':        return (          <Box>            <Flex justify="space-between" align="center" mb={2}>              <Badge colorScheme="cyan">仿生阅读</Badge>              {node.isSelected && (                <IconButton                  aria-label="编辑节点"                  icon={<FiEdit2 size="14px" />}                  size="xs"                  variant="ghost"                  onClick={(e) => {                    e.stopPropagation();                    const newContent = prompt("编辑仿生阅读内容", node.content);                    if (newContent !== null) {                      handleNodeEdit(node.id, newContent);                    }                  }}                />              )}            </Flex>            <Box dangerouslySetInnerHTML={{ __html: formatBionicText(node.content) }} />          </Box>        );              default:        return <Text>{node.content}</Text>;    }  };    // 计算连接线的路径  const calculateConnectionPath = (connection: any) => {    // 处理端口连接    if (connection.type === 'port-connection') {      // 解析源和目标      const [sourceNodeId, sourcePortId] = connection.source.split(':');      const [targetNodeId, targetPortId] = connection.target.split(':');            const sourceNode = nodes.find(node => node.id === sourceNodeId);      const targetNode = nodes.find(node => node.id === targetNodeId);            if (!sourceNode || !targetNode) {        return '';      }            // 获取源节点和目标节点的位置      const sourceX = sourceNode.position.x + 250; // 假设节点宽度为250px，输出端口在右侧      const sourceY = sourceNode.position.y + 100; // 假设节点高度为200px，端口在中间位置            const targetX = targetNode.position.x; // 输入端口在左侧      const targetY = targetNode.position.y + 100;            // 计算控制点，创建平滑的曲线      const dx = Math.abs(targetX - sourceX);      const controlPointOffset = Math.min(100, Math.max(50, dx / 3));            // 创建贝塞尔曲线路径      return `M ${sourceX} ${sourceY} C ${sourceX + controlPointOffset} ${sourceY}, ${targetX - controlPointOffset} ${targetY}, ${targetX} ${targetY}`;    }        // 处理普通节点连接    const sourceNode = nodes.find(node => node.id === connection.source);    const targetNode = nodes.find(node => node.id === connection.target);        if (!sourceNode || !targetNode) {      return '';    }        // 获取源节点和目标节点的中心点坐标    const sourceX = sourceNode.position.x + 125; // 假设节点宽度为250px    const sourceY = sourceNode.position.y + 75; // 假设节点高度为150px    const targetX = targetNode.position.x + 125;    const targetY = targetNode.position.y + 75;        // 寻找合适的连接点 - 这里使用简化的方法计算节点边缘的连接点    // 计算两点之间的角度    const angle = Math.atan2(targetY - sourceY, targetX - sourceX);        // 节点尺寸    const nodeWidth = 250;    const nodeHeight = 150;    const halfWidth = nodeWidth / 2;    const halfHeight = nodeHeight / 2;        // 源节点连接点    let sx, sy;    // 目标节点连接点    let tx, ty;        // 根据角度确定连接点在节点的哪个边    // 源节点    if (Math.abs(Math.cos(angle)) > Math.abs(Math.sin(angle))) {      // 连接线主要是水平方向      sx = sourceX + (Math.cos(angle) > 0 ? halfWidth : -halfWidth);      sy = sourceY + Math.tan(angle) * (Math.cos(angle) > 0 ? halfWidth : -halfWidth);            // 如果sy超出节点边界，则连接点在上边缘或下边缘      if (sy > sourceY + halfHeight) {        sy = sourceY + halfHeight;        sx = sourceX + halfHeight / Math.tan(angle);      } else if (sy < sourceY - halfHeight) {        sy = sourceY - halfHeight;        sx = sourceX - halfHeight / Math.tan(angle);      }    } else {      // 连接线主要是垂直方向      sy = sourceY + (Math.sin(angle) > 0 ? halfHeight : -halfHeight);      sx = sourceX + (Math.sin(angle) > 0 ? halfHeight : -halfHeight) / Math.tan(angle);            // 如果sx超出节点边界，则连接点在左边缘或右边缘      if (sx > sourceX + halfWidth) {        sx = sourceX + halfWidth;        sy = sourceY + halfWidth * Math.tan(angle);      } else if (sx < sourceX - halfWidth) {        sx = sourceX - halfWidth;        sy = sourceY - halfWidth * Math.tan(angle);      }    }        // 目标节点 - 使用相反的角度    if (Math.abs(Math.cos(angle)) > Math.abs(Math.sin(angle))) {      tx = targetX + (Math.cos(angle) < 0 ? halfWidth : -halfWidth);      ty = targetY + Math.tan(angle + Math.PI) * (Math.cos(angle) < 0 ? halfWidth : -halfWidth);            if (ty > targetY + halfHeight) {        ty = targetY + halfHeight;        tx = targetX + halfHeight / Math.tan(angle + Math.PI);      } else if (ty < targetY - halfHeight) {        ty = targetY - halfHeight;        tx = targetX - halfHeight / Math.tan(angle + Math.PI);      }    } else {      ty = targetY + (Math.sin(angle) < 0 ? halfHeight : -halfHeight);      tx = targetX + (Math.sin(angle) < 0 ? halfHeight : -halfHeight) / Math.tan(angle + Math.PI);            if (tx > targetX + halfWidth) {        tx = targetX + halfWidth;        ty = targetY + halfWidth * Math.tan(angle + Math.PI);      } else if (tx < targetX - halfWidth) {        tx = targetX - halfWidth;        ty = targetY - halfWidth * Math.tan(angle + Math.PI);      }    }        // 计算贝塞尔曲线控制点    const dx = Math.abs(tx - sx);    const dy = Math.abs(ty - sy);    const controlPointOffset = Math.min(100, Math.max(50, dx / 4 + dy / 4));        // 计算控制点，创建平滑的曲线    const cpx1 = sx + (tx - sx) / 3;    const cpy1 = sy + (ty - sy) / 3;    const cpx2 = sx + (tx - sx) * 2 / 3;    const cpy2 = sy + (ty - sy) * 2 / 3;        // 创建三次贝塞尔曲线路径    return `M ${sx} ${sy} C ${cpx1} ${cpy1}, ${cpx2} ${cpy2}, ${tx} ${ty}`;  };    // 获取连接线样式  const getConnectionStyle = (connection: any) => {    // 基础样式    const baseStyle = {      stroke: connectionColor,      strokeWidth: 2,      fill: 'none',      cursor: 'pointer'    };        // 根据连接类型返回不同样式    switch (connection.type) {      case 'port-connection':        return {          ...baseStyle,          stroke: 'green.400',          strokeWidth: 3,          strokeDasharray: '0'        };      case 'debate-connection':        return {          ...baseStyle,          stroke: 'purple.400',          strokeDasharray: '5,5'        };      case 'ai-connection':        return {          ...baseStyle,          stroke: 'blue.400',          strokeDasharray: '0'        };      default:        return baseStyle;    }  };    // 修改错误处理  const handleError = (error: any, operation: string) => {    console.error(`操作"${operation}"出错:`, error);        toast({      title: "操作失败",      description: `${operation}时发生错误: ${error.message || '未知错误'}`,      status: "error",      duration: 5000,      isClosable: true,    });  };    // 添加AI助手使用功能  const handleAIAssistant = async () => {    const selectedNodes = nodes.filter(node => node.isSelected);        if (selectedNodes.length === 0) {      toast({        title: "请先选择节点",        description: "选择一个或多个节点以使用AI助手",        status: "warning",        duration: 2000,        isClosable: true,      });      return;    }        toast({      title: "AI助手正在生成内容",      description: "正在分析所选节点...",      status: "info",      duration: 2000,      isClosable: true,    });        try {      // 从各种类型的节点中提取内容      const nodesContent = selectedNodes.map(node => {        // 提取不同类型节点的内容        let content = '';        let nodeType = '';                if (node.type === 'text' || node.type === 'bionicText') {          content = node.data?.content || node.content || '';          nodeType = '文本';        } else if (node.type === 'image') {          // 图片节点需要提取URL和说明文字          const url = node.data?.url || '';          const caption = node.data?.caption || '';          const alt = node.data?.alt || '';          content = `图片URL: ${url}\n图片说明: ${caption || alt || '无说明'}`;          nodeType = '图片';        } else if (node.type === 'ai') {          // AI节点需要提取提示词和回复          content = `提示词: ${node.data?.prompt || ''}\n回复: ${node.data?.response || ''}`;          nodeType = 'AI对话';        } else if (node.type === 'debate') {          // 辩论节点          content = node.data?.topic || node.content || '';          nodeType = '辩论主题';        } else if (node.type === 'link') {          // 链接节点          content = `标题: ${node.data?.title || ''}\n链接: ${node.data?.url || ''}\n描述: ${node.data?.description || ''}`;          nodeType = '链接';        } else if (node.type === 'port') {          // 端口节点          content = node.data?.content || node.content || '';          nodeType = '端口';        } else {          content = node.content || JSON.stringify(node.data) || '';          nodeType = node.type || '未知';        }                return { id: node.id, type: nodeType, content };      });            // 构建提示词      const prompt = `请基于以下${selectedNodes.length}个节点的内容生成深度分析和见解：\n\n${        nodesContent.map((node, index) =>           `节点 ${index + 1} (类型: ${node.type}):\n${node.content}`        ).join('\n\n')      }\n\n请提供对这些内容的综合分析，包括关键概念、潜在联系和重要见解。格式请使用Markdown，包含标题、小标题和要点列表。`;            // 使用默认模型配置      const defaultModel = 'qwen2.5:7b';  // 使用Ollama上的默认模型，可以根据需要调整            // 发送请求到AI服务      const response = await aiService.sendRequest({        model: defaultModel,        messages: [          { role: 'system', content: '你是Neurite-Storm的AI助手，擅长分析和整合不同类型节点的内容，提供有深度的见解。' },          { role: 'user', content: prompt }        ],        temperature: 0.7,        provider: 'ollama' // 默认使用Ollama，可以根据配置调整      });            if (!response || !response.text) {        throw new Error('AI服务返回空响应');      }            // 创建一个新的AI结果节点      const nodeId = uuidv4();      const newNode = {        id: nodeId,        type: 'ai',        position: {          x: -position.x + window.innerWidth / 2 / zoom - 150,           y: -position.y + window.innerHeight / 2 / zoom - 100        },        data: {          prompt,          response: response.text,          model: defaultModel,          temperature: 0.7,          contextNodes: selectedNodes.map(node => node.id),          updatedAt: new Date().toISOString()        },        isSelected: true      };            // 更新节点状态，取消选择其他节点      setNodes([        ...nodes.map(node => ({ ...node, isSelected: false })),        newNode      ]);            // 创建从源节点到新节点的连接      selectedNodes.forEach(sourceNode => {        const connectionId = uuidv4();        setConnections([          ...connections,          {            id: connectionId,            source: sourceNode.id,            target: nodeId,            label: 'AI分析'          }        ]);      });            toast({        title: "AI内容已生成",        status: "success",        duration: 1500,        isClosable: true,      });    } catch (error) {      console.error('AI内容生成失败:', error);      toast({        title: "AI内容生成失败",        description: error instanceof Error ? error.message : "未知错误",        status: "error",        duration: 3000,        isClosable: true,      });    }  };    // 计算节点和连接的样式  const getNodeStyle = (node: any) => {    const baseStyle = {      position: 'absolute',      left: `${node.position.x}px`,      top: `${node.position.y}px`,      transform: `scale(${zoom})`,      transformOrigin: 'center',      transition: isDragging || nodeDragging ? 'none' : 'all 0.2s ease',      zIndex: node.isSelected ? 2 : 1,      cursor: nodeDragging ? 'grabbing' : 'pointer'    };        const typeSpecificStyle = {      text: {        width: '200px',        padding: '16px',        borderRadius: '8px',        backgroundColor: nodeColor,        border: `2px solid ${node.isSelected ? selectedBorderColor : nodeBorderColor}`,        boxShadow: node.isSelected ? 'lg' : 'md',        transform: node.isSelected ? 'scale(1.02)' : 'scale(1)'      },      image: {        width: '160px',        padding: '8px',        borderRadius: '8px',        backgroundColor: nodeColor,        border: `2px solid ${node.isSelected ? selectedBorderColor : nodeBorderColor}`,        boxShadow: node.isSelected ? 'lg' : 'md',        cursor: 'pointer',        display: 'flex',        flexDirection: 'column',        alignItems: 'center',        transform: node.isSelected ? 'scale(1.02)' : 'scale(1)'      },      link: {        width: '200px',        padding: '12px',        borderRadius: '8px',        backgroundColor: nodeColor,        border: `2px solid ${node.isSelected ? selectedBorderColor : nodeBorderColor}`,        boxShadow: node.isSelected ? 'lg' : 'md',        cursor: 'pointer',        transform: node.isSelected ? 'scale(1.02)' : 'scale(1)'      },      ai: {        width: '280px',        padding: '12px',        borderRadius: '8px',        backgroundColor: nodeColor,        border: `2px solid ${node.isSelected ? selectedBorderColor : 'blue.200'}`,        borderTopColor: 'blue.400',        boxShadow: node.isSelected ? 'lg' : 'md',        cursor: 'pointer',        transform: node.isSelected ? 'scale(1.02)' : 'scale(1)'      },      debate: {        width: '320px',        padding: '12px',        borderRadius: '8px',        backgroundColor: nodeColor,        border: `2px solid ${node.isSelected ? selectedBorderColor : 'purple.200'}`,        borderTopColor: 'purple.400',        boxShadow: node.isSelected ? 'lg' : 'md',        cursor: 'pointer',        transform: node.isSelected ? 'scale(1.02)' : 'scale(1)'      },      port: {        width: '250px',        padding: '12px',        borderRadius: '8px',        backgroundColor: nodeColor,        border: `2px solid ${node.isSelected ? selectedBorderColor : 'orange.200'}`,        borderTopColor: 'orange.400',        boxShadow: node.isSelected ? 'lg' : 'md',        cursor: 'pointer',        transform: node.isSelected ? 'scale(1.02)' : 'scale(1)'      },      bionicText: {        width: '320px',        padding: '12px',        borderRadius: '8px',        backgroundColor: nodeColor,        border: `2px solid ${node.isSelected ? selectedBorderColor : 'cyan.200'}`,        borderTopColor: 'cyan.400',        boxShadow: node.isSelected ? 'lg' : 'md',        cursor: 'pointer',        transform: node.isSelected ? 'scale(1.02)' : 'scale(1)'      }    };        return { ...baseStyle, ...typeSpecificStyle[node.type] };  };    // 添加创建树节点的函数  const handleCreateNodeFromBranch = (branchId: string, nodeType: string) => {    const position = {      x: Math.random() * 800,      y: Math.random() * 600    };        let newNode;        switch (nodeType) {      case 'text':        newNode = createTextNode(`来自知识树-${branchId}`, position);        break;      case 'ai':        newNode = createChatNode(`来自知识树-${branchId}`, position);        break;      case 'debate':        newNode = addDebateNode(`来自知识树-${branchId}`, position);        break;      case 'port':        newNode = createPortNode(`来自知识树-${branchId}`, position);        break;      default:        newNode = createTextNode(`来自知识树-${branchId}`, position);    }        setNodes((els) => els.concat(newNode));    toast({      title: '已创建节点',      description: `已从知识树分支创建${nodeType}类型节点`,      status: 'success',      duration: 2000,      isClosable: true,    });  };    // 添加节点对齐功能  const alignSelectedNodes = (direction: 'horizontal' | 'vertical') => {    const selectedNodes = nodes.filter(node => node.isSelected);        if (selectedNodes.length <= 1) {      toast({        title: "无法对齐节点",        description: "请选择至少两个节点进行对齐",        status: "warning",        duration: 2000,        isClosable: true,      });      return;    }        saveToHistory();        // 计算平均位置    let alignPosition = 0;        if (direction === 'horizontal') {      // 水平对齐 - 计算所有选中节点的平均Y坐标      alignPosition = selectedNodes.reduce((sum, node) => sum + node.position.y, 0) / selectedNodes.length;            setNodes(nodes.map(node => {        if (node.isSelected) {          return {            ...node,            position: {              ...node.position,              y: alignPosition            }          };        }        return node;      }));    } else {      // 垂直对齐 - 计算所有选中节点的平均X坐标      alignPosition = selectedNodes.reduce((sum, node) => sum + node.position.x, 0) / selectedNodes.length;            setNodes(nodes.map(node => {        if (node.isSelected) {          return {            ...node,            position: {              ...node.position,              x: alignPosition            }          };        }        return node;      }));    }        toast({      title: `已${direction === 'horizontal' ? '水平' : '垂直'}对齐节点`,      status: "success",      duration: 1500,      isClosable: true,    });  };    // 添加自动布局功能  const autoArrangeNodes = () => {    if (nodes.length <= 1) {      toast({        title: "无法自动布局",        description: "节点数量不足",        status: "warning",        duration: 2000,        isClosable: true,      });      return;    }        saveToHistory();        // 简单的力导向布局算法    // 这里实现一个简化版本，实际项目中可以使用更复杂的算法        // 计算画布中心    const centerX = window.innerWidth / 2 / zoom - position.x / zoom;    const centerY = window.innerHeight / 2 / zoom - position.y / zoom;        // 节点间距    const nodeDistance = 250;        // 计算节点新位置    const newNodes = [...nodes];        // 如果节点数量少于等于5，使用环形布局    if (nodes.length <= 5) {      const radius = nodeDistance;      const angleStep = (2 * Math.PI) / nodes.length;            newNodes.forEach((node, index) => {        const angle = index * angleStep;        node.position = {          x: centerX + radius * Math.cos(angle),          y: centerY + radius * Math.sin(angle)        };      });    }     // 否则使用网格布局    else {      const cols = Math.ceil(Math.sqrt(nodes.length));      const rows = Math.ceil(nodes.length / cols);            const startX = centerX - (cols * nodeDistance) / 2;      const startY = centerY - (rows * nodeDistance) / 2;            newNodes.forEach((node, index) => {        const row = Math.floor(index / cols);        const col = index % cols;                node.position = {          x: startX + col * nodeDistance,          y: startY + row * nodeDistance        };      });    }        setNodes(newNodes);        toast({      title: "已自动布局节点",      status: "success",      duration: 1500,      isClosable: true,    });  };    // 添加创建节点的辅助函数  const createTextNode = (content: string, position?: { x: number, y: number }) => {    const id = `node${nodes.length + 1}`;    const nodePosition = position || {       x: window.innerWidth / 2 / zoom - position.x / zoom - 100,       y: window.innerHeight / 2 / zoom - position.y / zoom - 60     };        // 修改这里，避免使用未定义的position    const defaultPosition = {       x: window.innerWidth / 2 / zoom - 100,       y: window.innerHeight / 2 / zoom - 60     };        const finalPosition = position || {      x: defaultPosition.x - (position ? position.x / zoom : 0),      y: defaultPosition.y - (position ? position.y / zoom : 0)    };        return {      id,      type: 'text',      position: finalPosition,      content: content || '新文本节点',      isSelected: true    };  };    const createImageNode = (imageUrl: string, position?: { x: number, y: number }) => {    const id = `node${nodes.length + 1}`;        // 创建默认位置，不依赖于可能未定义的position    const defaultPosition = {       x: window.innerWidth / 2 / zoom - 100,       y: window.innerHeight / 2 / zoom - 60     };        return {      id,      type: 'image',      position: position || defaultPosition,      content: '图片节点',      data: {        url: imageUrl || 'https://via.placeholder.com/150'      },      isSelected: true    };  };    const createLinkNode = (url: string, position?: { x: number, y: number }) => {    const id = `node${nodes.length + 1}`;        // 创建默认位置，不依赖于可能未定义的position    const defaultPosition = {       x: window.innerWidth / 2 / zoom - 100,       y: window.innerHeight / 2 / zoom - 60     };        return {      id,      type: 'link',      position: position || defaultPosition,      content: url || 'https://example.com',      data: {        url: url || 'https://example.com'      },      isSelected: true    };  };    const createChatNode = (prompt: string, position?: { x: number, y: number }) => {    const id = `node${nodes.length + 1}`;        // 创建默认位置，不依赖于可能未定义的position    const defaultPosition = {       x: window.innerWidth / 2 / zoom - 100,       y: window.innerHeight / 2 / zoom - 60     };        return {      id,      type: 'ai',      position: position || defaultPosition,      content: prompt || '请输入您的问题...',      data: {        response: '',        model: 'gpt-4'      },      isSelected: true    };  };    const createDebateNode = (topic: string, position?: { x: number, y: number }) => {    const id = `node${nodes.length + 1}`;        // 创建默认位置，不依赖于可能未定义的position    const defaultPosition = {       x: window.innerWidth / 2 / zoom - 150,       y: window.innerHeight / 2 / zoom - 100     };        return {      id,      type: 'debate',      position: position || defaultPosition,      content: topic || '添加辩论话题',      data: {        topic: topic || '',        perspectives: [],        analysis: '',        persuasiveView: '',        settings: {          debateStyle: 'balanced',          complexity: 'moderate',          model: 'gpt-4'        }      },      isSelected: true    };  };    const createPortNode = (title: string, position?: { x: number, y: number }) => {    const id = `node${nodes.length + 1}`;        // 创建默认位置，不依赖于可能未定义的position    const defaultPosition = {       x: window.innerWidth / 2 / zoom - 150,       y: window.innerHeight / 2 / zoom - 100     };        return {      id,      type: 'port',      position: position || defaultPosition,      content: '',      data: {        title: title || '处理模块',        description: '用于处理数据的节点',        content: '这是一个处理模块节点，可以通过输入端口接收数据，经过处理后从输出端口发送结果。',        inputs: [          {            id: `port-in-${Date.now()}-1`,            name: '输入 1',            type: 'data',            direction: 'input',            dataType: 'any',            connections: [],            position: { x: 0, y: 0 }          }        ],        outputs: [          {            id: `port-out-${Date.now()}-1`,            name: '输出 1',            type: 'data',            direction: 'output',            dataType: 'any',            connections: [],            position: { x: 0, y: 0 }          }        ],        process: 'function process(input) {\n  return input;\n}',        format: 'markdown'      },      isSelected: true    };  };    const createBionicTextNode = (text: string, position?: { x: number, y: number }) => {    const id = `node${nodes.length + 1}`;        // 创建默认位置，不依赖于可能未定义的position    const defaultPosition = {       x: window.innerWidth / 2 / zoom - 150,       y: window.innerHeight / 2 / zoom - 100     };        return {      id,      type: 'bionicText',      position: position || defaultPosition,      content: text || '这是一个仿生阅读测试文本。仿生阅读通过强调单词前部分来帮助您更快地阅读和理解文本内容。这种技术可以提高阅读速度和阅读效率。',      data: {},      isSelected: true    };  };    // 添加打开多节点查询的函数  const openMultiNodeAnalysis = () => {    const hasSelectedNodes = nodes.filter(node => node.isSelected).length > 0;        if (!hasSelectedNodes) {      toast({        title: "请先选择节点",        description: "需要选择至少一个节点来进行多节点分析",        status: "warning",        duration: 2000,        isClosable: true,      });      return;    }        setIsMultiNodeQueryOpen(true);  };    // 添加打开AI设置的函数  const openAISettings = () => {    setIsAISettingsOpen(true);  };    // 添加关闭多节点查询的函数  const closeMultiNodeQuery = () => {    setIsMultiNodeQueryOpen(false);  };    // 添加关闭AI设置的函数  const closeAISettings = () => {    setIsAISettingsOpen(false);  };    // 添加从多节点分析创建节点的函数  const handleCreateNodeFromAnalysis = (nodeData: any) => {    saveToHistory();        let newNode;        if (typeof nodeData === 'string') {      // 兼容旧版本的调用方式      const content = nodeData;      const nodeType = arguments[1] || 'ai';            switch (nodeType) {        case 'text':          newNode = createTextNode(content);          break;        case 'bionic':          newNode = createBionicTextNode(content);          break;        case 'ai':        default:          newNode = createChatNode(content);          break;      }    } else {      // 新版本直接传递节点数据      switch (nodeData.type) {        case 'text':          newNode = createTextNode(nodeData.data?.content || nodeData.content);          break;        case 'bionic':          newNode = createBionicTextNode(nodeData.data?.content || nodeData.content);          break;        case 'debate':          newNode = createDebateNode(nodeData.data?.topic || nodeData.content);          break;        case 'port':          newNode = createPortNode(nodeData.content);          break;        case 'ai':        default:          newNode = createChatNode(nodeData.data?.content || nodeData.content);          break;      }    }        setNodes([      ...nodes.map(node => ({ ...node, isSelected: false })),      newNode    ]);        toast({      title: "已创建分析结果节点",      status: "success",      duration: 1500,      isClosable: true,    });  };    // 添加节点菜单项  const addNodeMenuItems = [    { label: '文本节点', icon: <FiFileText />, type: 'text' },    { label: '图片节点', icon: <FiImage />, type: 'image' },    { label: '链接节点', icon: <FiLink />, type: 'link' },    { label: 'AI节点', icon: <FiCpu />, type: 'ai' },    { label: 'AI代理节点', icon: <FiZap />, type: 'aiagent' },    { label: '问题节点', icon: <FiHelpCircle />, type: 'question' },    { label: '回答节点', icon: <FiMessageCircle />, type: 'answer' },    { label: '辩论节点', icon: <FiUsers />, type: 'debate' },    { label: '端口节点', icon: <FiArrowRightCircle />, type: 'port' },  ];    // 处理添加节点  const handleAddNode = (type: string) => {    const position = {      x: viewport.x + window.innerWidth / 2 / viewport.zoom - 100,      y: viewport.y + window.innerHeight / 2 / viewport.zoom - 100,    };    const id = uuidv4();    let newNode: INode;    switch (type) {      case 'text':        newNode = {          id,          type,          position,          data: {            content: '# 新文本节点\n\n在这里输入内容...',            format: 'markdown'          }        };        break;      case 'image':        newNode = {          id,          type,          position,          data: {            src: '',            alt: '图片描述',            caption: '图片标题'          }        };        break;      case 'link':        newNode = {          id,          type,          position,          data: {            url: 'https://example.com',            title: '链接标题',            description: '链接描述'          }        };        break;      case 'ai':        newNode = {          id,          type,          position,          data: {            prompt: '请输入你的问题...',            response: '',            model: 'gpt-3.5-turbo',            temperature: 0.7,            contextNodes: []          }        };        break;      case 'aiagent':        newNode = {          id,          type,          position,          data: {            mode: 'generate',            result: '',            selectedNodeIds: [],            generationOptions: {              count: 3,              nodeType: 'text',              topic: ''            },            relationOptions: {              relationTypes: [],              bidirectional: false            },            agentOptions: {              provider: 'openai',              model: 'gpt-3.5-turbo',              temperature: 0.7,              systemPrompt: ''            }          }        };        break;      case 'question':        newNode = {          id,          type,          position,          data: {            question: '在这里输入你的问题...',            details: '可以在这里添加更多细节...',            tags: []          }        };        break;      case 'answer':        newNode = {          id,          type,          position,          data: {            content: '在这里输入你的回答...',            sources: [],            votes: 0          }        };        break;      case 'debate':        newNode = {          id,          type,          position,          data: {            topic: '辩论主题',            description: '辩论描述',            proArguments: [],            conArguments: []          }        };        break;      case 'port':        newNode = {          id,          type,          position,          data: {            label: '连接端口',            direction: 'input',            connectedTo: []          }        };        break;      default:        return;    }    dispatch(addNode(newNode));    setSelectedNodeId(id);  };    return (    <Box>      {/* 顶部工具栏 */}      <Flex         p={4}         bg={headerBgColor}         borderBottomWidth="1px"         borderColor={headerBorderColor}        justifyContent="space-between"        alignItems="center"      >        {/* 左侧标题 */}        <Heading size="md">{graphTitle}</Heading>                {/* 右侧工具栏 */}        <HStack spacing={2}>          {/* 添加节点按钮 */}          <Menu>            <MenuButton               as={Button}               rightIcon={<FiPlus />}              colorScheme="blue"              size="sm"            >              添加节点            </MenuButton>            <MenuList>              {addNodeMenuItems.map(item => (                <MenuItem key={item.type} icon={item.icon} onClick={() => handleAddNode(item.type)}>                  {item.label}                </MenuItem>              ))}            </MenuList>          </Menu>                    {/* 连接节点按钮 */}          <Tooltip label="连接节点">            <Button              leftIcon={<FiLink />}              size="sm"              onClick={connectSelectedNodes}            >              连接节点            </Button>          </Tooltip>                    {/* 多节点分析按钮 */}          <Tooltip label="多节点分析">            <IconButton              aria-label="多节点分析"              icon={<FiLayers />}              size="sm"              colorScheme={nodes.filter(node => node.isSelected).length > 0 ? "purple" : "gray"}              onClick={openMultiNodeAnalysis}            />          </Tooltip>                    {/* 辩论助手按钮 - 新增 */}          <Tooltip label="辩论式思考">            <IconButton              aria-label="辩论式思考"              icon={<FiMessageSquare />}              size="sm"              colorScheme="orange"              onClick={onOpenDebate}            />          </Tooltip>                    {/* AI设置按钮 */}          <Tooltip label="AI模型设置">            <IconButton              aria-label="AI模型设置"              icon={<FiSettings />}              size="sm"              colorScheme="teal"              onClick={openAISettings}            />          </Tooltip>                    <Divider orientation="vertical" height="24px" />                    {/* 布局菜单按钮 */}          <Menu>            <MenuButton              as={IconButton}              aria-label="布局选项"              icon={<FiMaximize />}              size="sm"            />            <MenuList>              <MenuItem onClick={() => alignSelectedNodes('horizontal')}>水平对齐节点</MenuItem>              <MenuItem onClick={() => alignSelectedNodes('vertical')}>垂直对齐节点</MenuItem>              <MenuItem onClick={autoArrangeNodes}>自动布局</MenuItem>            </MenuList>          </Menu>                    <Divider orientation="vertical" height="24px" />                    {/* 保存按钮 */}          <Tooltip label="保存图谱">            <IconButton              aria-label="保存图谱"              icon={<FiSave />}              size="sm"              onClick={() => {                // 实际应用中会调用Redux action                toast({                  title: "图谱已保存",                  status: "success",                  duration: 2000,                  isClosable: true,                });              }}            />          </Tooltip>                    {/* 共享按钮 */}          <Tooltip label="共享图谱">            <IconButton              aria-label="共享图谱"              icon={<FiShare2 />}              size="sm"              onClick={() => {                // 实际应用中会显示共享对话框                toast({                  title: "分享功能开发中",                  description: "即将支持多人协作编辑",                  status: "info",                  duration: 2000,                  isClosable: true,                });              }}            />          </Tooltip>                    {/* 知识树按钮 */}          <Tooltip label="知识树">            <IconButton              aria-label="Knowledge Tree"              icon={<FiGitBranch />}              onClick={() => setIsKnowledgeTreeOpen(true)}              variant="ghost"              size="sm"            />          </Tooltip>                    {/* 更多选项 */}          <Menu>            <MenuButton              as={IconButton}              aria-label="更多选项"              icon={<FiMoreVertical />}              size="sm"            />            <MenuList>              <MenuItem onClick={() => {                const selectedIds = nodes.filter(node => node.isSelected).map(node => node.id);                if (selectedIds.length === 0) {                  toast({                    title: "请先选择要删除的节点",                    status: "warning",                    duration: 2000,                    isClosable: true,                  });                  return;                }                                // 删除节点                setNodes(nodes.filter(node => !node.isSelected));                                // 删除相关连接                setConnections(connections.filter(                  conn => !selectedIds.includes(conn.source) && !selectedIds.includes(conn.target)                ));                                toast({                  title: `已删除 ${selectedIds.length} 个节点`,                  status: "success",                  duration: 1500,                  isClosable: true,                });              }}>删除选中节点</MenuItem>              <MenuItem onClick={() => setShowMiniMap(!showMiniMap)}>                {showMiniMap ? '隐藏小地图' : '显示小地图'}              </MenuItem>              <MenuItem onClick={() => onOpen()}>打开AI助手</MenuItem>            </MenuList>          </Menu>                    {/* 撤销按钮 */}          <Tooltip label="撤销">            <IconButton              aria-label="撤销"              icon={<FiRotateCcw />}              size="sm"              onClick={undo}              isDisabled={historyIndex <= 0}            />          </Tooltip>                    {/* 重做按钮 */}          <Tooltip label="重做">            <IconButton              aria-label="重做"              icon={<FiRotateCw />}              size="sm"              onClick={redo}              isDisabled={historyIndex >= history.length - 1}            />          </Tooltip>        </HStack>      </Flex>            {/* 主画布区域 */}      <Box        ref={canvasRef}        position="relative"        width="100%"        height="calc(100vh - 64px)"        bg={bgColor}        overflow="hidden"        cursor={isDragging ? "grabbing" : "default"}        onMouseDown={handleCanvasMouseDown}        onMouseMove={handleCanvasMouseMove}        onMouseUp={handleCanvasMouseUp}        onMouseLeave={handleCanvasMouseUp}      >        {/* 操作提示 */}        <Box          position="absolute"          bottom="20px"          left="20px"          p={2}          bg={modalBgColor}          borderRadius="md"          boxShadow="md"          fontSize="xs"          zIndex={2}          maxW="300px"        >          <Text fontWeight="bold" mb={1}>操作提示:</Text>          <Text mb={1}>• 单击选择节点</Text>          <Text mb={1}>• 按住Shift键单击可选择多个节点</Text>          <Text mb={1}>• 按住Shift键在空白处拖动可框选多个节点</Text>          <Text mb={1}>• 拖动节点可移动位置</Text>          <Text mb={1}>• 选择多个节点后可一起拖动</Text>          <Text fontWeight="bold" mt={2} mb={1}>快捷键:</Text>          <Text mb={1}>• Ctrl+A: 全选节点</Text>          <Text mb={1}>• Delete: 删除选中节点</Text>          <Text mb={1}>• Ctrl+C: 复制选中节点</Text>          <Text mb={1}>• Ctrl+V: 粘贴节点</Text>          <Text>• ESC: 取消选择</Text>        </Box>                {/* 缩放控制 */}        <Box position="absolute" bottom="20px" right="20px" zIndex={2}>          <VStack spacing={2}>            <IconButton              aria-label="放大"              icon={<FiZoomIn />}              onClick={handleZoomIn}              size="sm"              colorScheme="gray"              variant="solid"            />            <IconButton              aria-label="缩小"              icon={<FiZoomOut />}              onClick={handleZoomOut}              size="sm"              colorScheme="gray"              variant="solid"            />            <IconButton              aria-label="重置缩放"              icon={<FiMaximize />}              onClick={handleResetZoom}              size="sm"              colorScheme="gray"              variant="solid"            />          </VStack>        </Box>                {/* 显示已选节点数量 */}        {nodes.filter(node => node.isSelected).length > 0 && (          <Box            position="absolute"            top="20px"            left="20px"            px={3}            py={1}            bg="purple.500"            color="white"            borderRadius="full"            fontSize="sm"            zIndex={2}          >            已选择 {nodes.filter(node => node.isSelected).length} 个节点          </Box>        )}                {/* 画布内容 - 节点和连接 */}        <Box          position="absolute"          left={`${position.x}px`}          top={`${position.y}px`}          transform={`scale(${zoom})`}          transformOrigin="top left"        >          {/* 选择框 */}          {selectionBox.isActive && (            <Box              position="absolute"              left={`${Math.min(selectionBox.start.x, selectionBox.end.x)}px`}              top={`${Math.min(selectionBox.start.y, selectionBox.end.y)}px`}              width={`${Math.abs(selectionBox.end.x - selectionBox.start.x)}px`}              height={`${Math.abs(selectionBox.end.y - selectionBox.start.y)}px`}              border="2px dashed"              borderColor="purple.400"              backgroundColor="purple.100"              opacity={0.3}              pointerEvents="none"            />          )}                    {/* 连接线层 */}          <svg width="10000" height="10000" style={{ position: 'absolute', top: 0, left: 0, pointerEvents: 'none' }}>            {connections.map((connection) => {              const path = calculateConnectionPath(connection);              const style = getConnectionStyle(connection);                            return (                <g key={connection.id}>                  {/* 连接线阴影，增加立体感 */}                  <path                    d={path}                    fill="none"                    stroke="rgba(0,0,0,0.15)"                    strokeWidth={style.strokeWidth + 2}                    strokeDasharray={style.strokeDasharray}                    style={{                       filter: 'blur(3px)',                      pointerEvents: 'none'                    }}                    transform="translate(2,2)"                  />                                    {/* 主连接线 */}                  <path                    d={path}                    fill="none"                    stroke={style.stroke}                    strokeWidth={style.strokeWidth}                    strokeDasharray={style.strokeDasharray}                    markerEnd={connection.type === 'port-connection' ? 'url(#arrow-port)' : 'url(#arrow)'}                    style={{                       cursor: 'pointer',                       pointerEvents: 'auto',                      transition: 'stroke 0.3s, stroke-width 0.2s'                    }}                    onClick={() => handleConnectionClick(connection.id)}                  />                                    {/* 透明宽线条，增大点击区域 */}                  <path                    d={path}                    fill="none"                    stroke="transparent"                    strokeWidth="15"                    style={{ cursor: 'pointer', pointerEvents: 'auto' }}                    onClick={() => handleConnectionClick(connection.id)}                  />                </g>              );            })}            <defs>              <marker                id="arrow"                viewBox="0 0 10 10"                refX="5"                refY="5"                markerWidth="6"                markerHeight="6"                orient="auto-start-reverse"              >                <path d="M 0 0 L 10 5 L 0 10 z" fill={connectionColor} />              </marker>              <marker                id="arrow-port"                viewBox="0 0 10 10"                refX="5"                refY="5"                markerWidth="6"                markerHeight="6"                orient="auto-start-reverse"              >                <path d="M 0 0 L 10 5 L 0 10 z" fill="green" />              </marker>            </defs>          </svg>                    {/* 节点层 */}          {nodes.map((node) => (            <Box              key={node.id}              position="absolute"              left={`${node.position.x}px`}              top={`${node.position.y}px`}              style={{                ...getNodeStyle(node),                left: undefined,                top: undefined,                position: undefined              }}              onClick={(e) => handleNodeSelect(node.id, e)}              onMouseDown={(e) => handleNodeDragStart(node.id, e)}            >              {renderNodeContent(node)}            </Box>          ))}        </Box>                {/* 小地图 */}        {showMiniMap && (          <Box            position="absolute"            right="20px"            top="20px"            width="200px"            height="150px"            bg={drawerBgColor}            borderWidth="1px"            borderColor={drawerBorderColor}            borderRadius="md"            boxShadow="md"            overflow="hidden"          >            {/* 简化的小地图实现 */}            <Box p={2} fontSize="xs" fontWeight="medium" borderBottomWidth="1px">              地图概览            </Box>            <Box p={2} position="relative" height="120px">              {nodes.map((node) => (                <Box                  key={`mini-${node.id}`}                  position="absolute"                  left={`${(node.position.x / 5000) * 100}%`}                  top={`${(node.position.y / 5000) * 100}%`}                  width="6px"                  height="6px"                  borderRadius="full"                  bg={node.isSelected ? 'blue.500' : 'gray.400'}                />              ))}              <Box                position="absolute"                border="1px dashed"                borderColor="red.400"                left={`${(-position.x / 5000) * 100}%`}                top={`${(-position.y / 5000) * 100}%`}                width={`${(window.innerWidth * zoom / 5000) * 100}%`}                height={`${(window.innerHeight * zoom / 5000) * 100}%`}              />            </Box>          </Box>        )}      </Box>            {/* AI助手抽屉 */}      <Drawer isOpen={isOpen} placement="right" onClose={onClose} size="md">        <DrawerOverlay />        <DrawerContent>          <DrawerCloseButton />          <DrawerHeader>Neurite AI助手</DrawerHeader>                    <DrawerBody>            <Box mb={4}>              <Text mb={2} fontWeight="medium">选择要使用的功能:</Text>                            <Button                leftIcon={<FiZap />}                colorScheme="blue"                variant="outline"                mb={2}                width="100%"                onClick={handleAIAssistant}              >                AI内容生成              </Button>                            <Button                leftIcon={<FiActivity />}                colorScheme="purple"                variant="outline"                mb={2}                width="100%"                onClick={() => {                  const selectedNodes = nodes.filter(node => node.isSelected);                                    if (selectedNodes.length === 0) {                    toast({                      title: "请先选择一个节点",                      description: "选择一个节点以开始多角度思考",                      status: "warning",                      duration: 2000,                      isClosable: true,                    });                    return;                  }                                    onOpenDebate();                }}              >                辩论式思考              </Button>                            <Button                leftIcon={<FiLayers />}                colorScheme="teal"                variant="outline"                width="100%"                onClick={() => {                  const selectedNodes = nodes.filter(node => node.isSelected);                                    if (selectedNodes.length === 0) {                    toast({                      title: "请先选择节点",                      description: "选择一个或多个节点进行分析",                      status: "warning",                      duration: 2000,                      isClosable: true,                    });                    return;                  }                                    onOpenMultiNode();                }}              >                多节点分析              </Button>            </Box>                        <Divider my={4} />                        <Box>              <Text fontSize="sm" color="gray.500">                AI助手可以帮助你生成内容、进行多角度思考分析和连接你的想法。                选择上方的功能或使用图谱上下文按钮直接访问相应功能。              </Text>            </Box>          </DrawerBody>        </DrawerContent>      </Drawer>            {/* 辩论助手 */}      <DebateAssistant        isOpen={isDebateOpen}        onClose={onCloseDebate}        selectedNodes={nodes.filter(node => node.isSelected)}        onAddNode={handleAddDebateNode}        onAddEdge={(edge) => {          // 添加新的边          dispatch(addEdge(edge));          return edge.id;        }}      />            {/* 多节点分析 */}      <MultiNodeQuery        isOpen={isMultiNodeQueryOpen}        onClose={closeMultiNodeQuery}        selectedNodes={nodes.filter(node => node.isSelected)}        onCreateNode={handleCreateNodeFromAnalysis}      />            {/* 知识树抽屉 */}      <Drawer        isOpen={isKnowledgeTreeOpen}        placement="right"        onClose={() => setIsKnowledgeTreeOpen(false)}        size="md"      >        <DrawerOverlay />        <DrawerContent>          <DrawerCloseButton />          <DrawerHeader>达朗贝尔知识树</DrawerHeader>                    <DrawerBody>            <KnowledgeTree               onCreateNode={handleCreateNodeFromBranch}              onBranchSelect={(branchId) => {                console.log(`选择分支: ${branchId}`);              }}            />          </DrawerBody>        </DrawerContent>      </Drawer>            {/* AI模型设置 */}      <Modal        isOpen={isAISettingsOpen}        onClose={closeAISettings}        size="xl"      >        <ModalOverlay />        <ModalContent>          <ModalCloseButton />          <AIModelSettings />        </ModalContent>      </Modal>    </Box>  );};export default GraphPage; 